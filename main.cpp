#line 229 "needlet_decomp.nw"
#include <cstdlib>   // For `atoi' and `atof'
#include <iostream>
#include <sstream>
#include <string>
#include <vector>
#line 239 "needlet_decomp.nw"
#include <gsl/gsl_math.h>
#include <fitsio.h>
#line 247 "needlet_decomp.nw"
#include <alm.h>
#include <alm_fitsio.h>
#include <alm_healpix_tools.h>
#include <datatypes.h>
#include <healpix_base.h>
#include <healpix_map.h>
#include <healpix_map_fitsio.h>
#line 261 "needlet_decomp.nw"
#include <config.h> // Generated by "configure"
#include "needlets.hpp"

#line 270 "needlet_decomp.nw"
std::string input_file_name;
double b_parameter;
int j_min;
int j_max;

#line 213 "needlet_decomp.nw"
int main(int argc, char ** argv)
{
    
#line 280 "needlet_decomp.nw"
if (argc != 5)
{
    std::cerr << "Usage: needlet_decomp MAP_FILE B_PARAM MIN_J MAX_J\n";
    return 1;
}

input_file_name = argv[1];

if ((b_parameter = std::atof(argv[2])) <= 0.0)
{
    std::cerr << "The B parameter must be a positive number\n";
    return 1;
}

if (   (j_min = std::atoi(argv[3])) < 0
    || (j_max = std::atoi(argv[4])) < 0)
{
    std::cerr << "The number of components must be positive\n";
    return 1;
}
#line 216 "needlet_decomp.nw"
    
#line 318 "needlet_decomp.nw"
Healpix_Map<double> input_map;
std::cerr << "Reading map " << input_file_name << '\n';
read_Healpix_map_from_fits(input_file_name, input_map);
if(input_map.Scheme() != RING)
{
    std::cerr << "Converting map into RING scheme\n";
    input_map.swap_scheme();
}
std::cerr << "Map read into memory\n";

unsigned long num_of_flagged_pixels = 0;
arr<double> map_pixels = input_map.Map();
for (unsigned long i = 0; i < map_pixels.size(); ++i)
{
    if (map_pixels[i] < -1.6e+30 || ! gsl_finite(map_pixels[i]))
    {
	map_pixels[i] = 0.0;
	num_of_flagged_pixels++;
    }
}
if (num_of_flagged_pixels > 0)
    std::cout << num_of_flagged_pixels
              << " pixels were flagged and set to zero\n";

input_map.Set(map_pixels, input_map.Scheme());
#line 351 "needlet_decomp.nw"
unsigned int l_max = 3 * input_map.Nside() - 1;
unsigned int m_max = l_max;

Alm<xcomplex<double> > input_alm(l_max, m_max);
arr<double> ring_weights(2 * input_map.Nside());
for (size_t i = 0; i < ring_weights.size(); ++i)
    ring_weights[i] = 1.0;

std::cerr << "Decomposing the map into its spherical harmonics...\n";
map2alm_iter(input_map, input_alm, 5, ring_weights);
std::cerr << "...done\n";
#line 217 "needlet_decomp.nw"
    
#line 377 "needlet_decomp.nw"
arr<double> ang_scales(l_max + 1);
for (unsigned int l = 0; l <= l_max; ++l)
    ang_scales[l] = l;

needlet_t * needlet = needlet_init(b_parameter, input_map.Nside());
#line 392 "needlet_decomp.nw"
for(int j = j_min; j <= j_max; ++j)
{
    std::cerr << "Processing j = " << j << '\n';

    arr<double> filter(l_max + 1);
    Alm<xcomplex<double> > output_alm;
    output_alm = input_alm;

    std::cerr << "    estimating the window function\n";
    window_function(needlet, j, l_max + 1,
		    ang_scales.begin(), filter.begin());

    std::cerr << "    filtering the alm coefficients\n";
    output_alm.ScaleL(filter);

    std::stringstream cur_file_name;
    cur_file_name << "needlet-alm-" << j << ".fits";
    std::cerr << "    saving the alm parameters in "
              << cur_file_name.str() << '\n';
    write_Alm_to_fits(std::string("!") + cur_file_name.str(),
                      output_alm, l_max, m_max, PLANCK_FLOAT64);

    Healpix_Map<double> output_map(input_map.Nside(), RING, SET_NSIDE);
    std::cerr << "    converting the coefficients into a map\n";
    alm2map(output_alm, output_map);

    cur_file_name.str("");  // Reset the stream
    cur_file_name << "needlet-map-" << j << ".fits";
    write_Healpix_map_to_fits(std::string("!") + cur_file_name.str(),
                              output_map, PLANCK_FLOAT64);
    std::cerr << "File " << cur_file_name.str() << " written to disk\n";
}
needlet_free(needlet);

#line 219 "needlet_decomp.nw"
    return 0;
}
